<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined">
    <title>AR Soyuzmultfilm</title>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="dom-overlay">
        <span id="add_icon" class="material-icons-outlined">add_circle</span>
        <span id="loading_text" style="display: none;">–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏...</span>
        <div id="error_message" style="display: none; color: red;"></div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                console.log('üöÄ –ù–∞—á–∞–ª–æ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
                
                let canvas = document.getElementById('renderCanvas');
                let domOverlay = document.querySelector('#dom-overlay');
                let addIcon = document.querySelector('#add_icon');
                let loadingText = document.querySelector('#loading_text');
                let errorMessage = document.querySelector('#error_message');

                // –°–æ–∑–¥–∞–µ–º –¥–≤–∏–∂–æ–∫ —Å –æ—Ç–ª–∞–¥–∫–æ–π
                let engine = new BABYLON.Engine(canvas, true, {
                    preserveDrawingBuffer: true,
                    stencil: true
                });
                
                console.log('‚úÖ –î–≤–∏–∂–æ–∫ —Å–æ–∑–¥–∞–Ω');

                let scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

                // –í–∫–ª—é—á–∞–µ–º –æ—Ç–ª–∞–¥–∫—É
                scene.debugLayer.show().catch(err => {
                    console.log('Debug layer –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω:', err);
                });

                // –û—Å–≤–µ—â–µ–Ω–∏–µ
                let light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
                light.intensity = 0.8;
                console.log('‚úÖ –û—Å–≤–µ—â–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ');

                // –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–µ–º –æ–±—ã—á–Ω—É—é –∫–∞–º–µ—Ä—É –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                let camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 5, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvas, true);

                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞
                const checkFileExists = async (url) => {
                    try {
                        const response = await fetch(url, { method: 'HEAD' });
                        return response.ok;
                    } catch (error) {
                        return false;
                    }
                };

                // –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏
                const loadModel = async (modelPath, scene) => {
                    console.log('üîÑ –ü—ã—Ç–∞—é—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å:', modelPath);
                    loadingText.style.display = 'block';
                    errorMessage.style.display = 'none';
                    
                    try {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
                        const fileExists = await checkFileExists(modelPath);
                        if (!fileExists) {
                            throw new Error(`–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: ${modelPath}`);
                        }

                        console.log('‚úÖ –§–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–∞—á–∏–Ω–∞—é –∑–∞–≥—Ä—É–∑–∫—É...');

                        // –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
                        const result = await BABYLON.SceneLoader.ImportMeshAsync(
                            null, // –∑–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –º–µ—à–∏
                            getBasePath(modelPath), // –±–∞–∑–æ–≤—ã–π –ø—É—Ç—å
                            getFileName(modelPath), // –∏–º—è —Ñ–∞–π–ª–∞
                            scene,
                            (progress) => {
                                console.log(`–ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∑–∫–∏: ${progress.loaded}/${progress.total}`);
                            }
                        );

                        console.log('‚úÖ –ú–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!');
                        console.log('- –ú–µ—à–µ–π:', result.meshes.length);
                        console.log('- –ú–∞—Ç–µ—Ä–∏–∞–ª–æ–≤:', result.materials ? result.materials.length : 0);
                        console.log('- –ê–Ω–∏–º–∞—Ü–∏–π:', result.animationGroups ? result.animationGroups.length : 0);

                        const model = result.meshes[0];
                        model.name = "loaded-model";
                        
                        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
                        const boundingBox = model.getBoundingInfo().boundingBox;
                        const size = boundingBox.maximum.subtract(boundingBox.minimum);
                        const maxSize = Math.max(size.x, size.y, size.z);
                        const scale = 0.5 / maxSize; // –ß—Ç–æ–±—ã –º–æ–¥–µ–ª—å –±—ã–ª–∞ –ø—Ä–∏–º–µ—Ä–Ω–æ 0.5 –µ–¥–∏–Ω–∏—Ü –≤ —Ä–∞–∑–º–µ—Ä–µ
                        
                        model.scaling = new BABYLON.Vector3(scale, scale, scale);
                        model.position = new BABYLON.Vector3(0, 0, -2);
                        
                        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                        if (model.material) {
                            model.material.backFaceCulling = false;
                        }
                        
                        loadingText.style.display = 'none';
                        return model;
                        
                    } catch (error) {
                        console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
                        loadingText.style.display = 'none';
                        errorMessage.textContent = `–û—à–∏–±–∫–∞: ${error.message}`;
                        errorMessage.style.display = 'block';
                        
                        // –°–æ–∑–¥–∞–µ–º fallback –∫—É–±–∏–∫
                        console.log('üîÑ –°–æ–∑–¥–∞—é fallback –∫—É–±–∏–∫...');
                        let box = BABYLON.MeshBuilder.CreateBox('fallback', { size: 0.3 }, scene);
                        let material = new BABYLON.StandardMaterial('fallback-mat', scene);
                        material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                        material.alpha = 0.8;
                        box.material = material;
                        box.position = new BABYLON.Vector3(0, 0, -2);
                        
                        return box;
                    }
                };

                // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—É—Ç—è–º–∏
                function getBasePath(fullPath) {
                    return fullPath.substring(0, fullPath.lastIndexOf('/') + 1);
                }

                function getFileName(fullPath) {
                    return fullPath.substring(fullPath.lastIndexOf('/') + 1);
                }

                // –¢–µ—Å—Ç–æ–≤—ã–µ –ø—É—Ç–∏ –∫ –º–æ–¥–µ–ª—è–º (—Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –Ω—É–∂–Ω—ã–π)
                const testModels = [
                   "ar-sculptures/assets/models/cheburashka.glb"
                ];

                // –ü–æ–ø—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–∞–∂–¥—É—é –º–æ–¥–µ–ª—å –ø–æ–∫–∞ –æ–¥–Ω–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
                const loadFirstAvailableModel = async () => {
                    for (let modelPath of testModels) {
                        console.log(`üîÑ –ü—Ä–æ–±—É—é –∑–∞–≥—Ä—É–∑–∏—Ç—å: ${modelPath}`);
                        try {
                            const model = await loadModel(modelPath, scene);
                            if (model && model.name !== 'fallback') {
                                console.log(`‚úÖ –£—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –º–æ–¥–µ–ª—å: ${modelPath}`);
                                return model;
                            }
                        } catch (error) {
                            console.log(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å ${modelPath}:`, error.message);
                            continue;
                        }
                    }
                    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∏ –æ–¥–Ω—É –º–æ–¥–µ–ª—å');
                };

                // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—É—é –º–æ–¥–µ–ª—å
                console.log('üîÑ –ó–∞–≥—Ä—É–∂–∞—é –Ω–∞—á–∞–ª—å–Ω—É—é –º–æ–¥–µ–ª—å...');
                let initialModel = await loadFirstAvailableModel();
                console.log('‚úÖ –ù–∞—á–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞');

                // –¢–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º XR
                console.log('üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é XR...');
                let xr = await scene.createDefaultXRExperienceAsync({
                    uiOptions: {
                        sessionMode: 'immersive-ar',
                        referenceSpaceType: 'local-floor',
                    }
                });

                let xrCamera = xr.baseExperience.camera;

                // DOM Overlay
                let featuresManager = xr.baseExperience.featuresManager;
                featuresManager.enableFeature(BABYLON.WebXRDomOverlay, 'latest', {
                    element: '#dom-overlay'
                }, undefined, false);

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è XR
                xr.baseExperience.onStateChangedObservable.add((webXRState) => {
                    console.log('XR State:', webXRState);
                    switch(webXRState) {
                        case BABYLON.WebXRState.IN_XR:
                            domOverlay.style.display = 'flex';
                            // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ XR –∫–∞–º–µ—Ä—É
                            scene.activeCamera = xrCamera;
                            break;
                        case BABYLON.WebXRState.EXITING_XR:
                            domOverlay.style.display = 'none';
                            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –æ–±—ã—á–Ω–æ–π –∫–∞–º–µ—Ä–µ
                            scene.activeCamera = camera;
                            break;
                    }
                });

                let activeElement = null;

                // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç —Å –º–æ–¥–µ–ª—å—é
                const createObject = async () => {
                    try {
                        console.log('üîÑ –°–æ–∑–¥–∞—é –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç...');
                        const model = await loadFirstAvailableModel();
                        
                        // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ–π
                        const currentCamera = scene.activeCamera;
                        if (currentCamera.getFrontPosition) {
                            model.position = currentCamera.getFrontPosition(1);
                        } else {
                            model.position = new BABYLON.Vector3(0, 0, -2);
                        }
                        
                        // –ê–Ω–∏–º–∞—Ü–∏—è –≤—Ä–∞—â–µ–Ω–∏—è
                        scene.registerBeforeRender(() => {
                            model.rotation.y += 0.01;
                        });
                        
                        activeElement = model;
                        console.log('‚úÖ –ù–æ–≤—ã–π –æ–±—ä–µ–∫—Ç —Å–æ–∑–¥–∞–Ω');
                        
                    } catch (error) {
                        console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞:', error);
                    }
                };

                // –†–µ–Ω–¥–µ—Ä-–ª—É–ø
                engine.runRenderLoop(() => {
                    scene.render();
                });

                console.log('‚úÖ –†–µ–Ω–¥–µ—Ä-–ª—É–ø –∑–∞–ø—É—â–µ–Ω');

                // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞
                addIcon.addEventListener('click', createObject);

                window.addEventListener('resize', () => {
                    engine.resize();
                });

                console.log('üéâ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∂–µ–Ω–æ!');

            } catch (error) {
                console.error('üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', error);
                alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: ' + error.message);
            }
        });
    </script>
</body>
</html>